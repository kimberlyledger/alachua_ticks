---
title: "Alachua County Ticks"
author: "Kimberly Ledger"
date: "2/17/2022"
output: html_document
---

# Part 1: Explore tick abundance data 

Load libraries 
```{r message=FALSE}
library(tidyverse)
library(car)
library(MASS)
library(stargazer)
library(effects)
library(ggplot2)
library(MuMIn)  #for model selection
library(spdep)
```

Read in the raw Alachua County tick dataset 
```{r}
ticks <- read.csv("AlachuaTicksAllSites.csv")
head(ticks)
```

How many individuals of each species and life stage were collected? 
```{r, message=FALSE}
ticks %>%
  group_by(Species, Lifestage) %>%
  summarise(total = n())
```
How many individuals of each species were collected in natural vs manicured sites? 
```{r, message=FALSE}
ticks %>%
  group_by(Species, Field_Type) %>%
  summarise(total = n())
```

How many individuals were collected at each visit? 
First plot combined, and then by species, and then by life stage of each species 
```{r, message=FALSE}
visit <- ticks %>%
  group_by(Visit) %>%
  summarise(total = n())

ggplot(data = visit, aes(x=Visit, y=total)) + 
  theme_classic() + 
  geom_point() + 
  labs(title = "tick abundance - all species combined", x = "Visit", y = "# of ticks")

visit_species <- ticks %>%
  group_by(Species, Visit) %>%
  summarise(total = n())

ggplot(data = visit_species, aes(x=Visit, y=total, fill = Species)) + 
  theme_classic() + 
  geom_point(aes(color = Species)) + 
  labs(title = "tick abundance - by species", x = "Visit", y = "# of ticks (adults and nymphs)")

visit_species_lifestage <- ticks %>%
  unite("Spp_Lifestage", Species, Lifestage) %>%
  group_by(Spp_Lifestage, Visit) %>%
  summarise(total = n())

ggplot(data = visit_species_lifestage, aes(x=Visit, y=total, fill = Spp_Lifestage)) + 
  theme_classic() + 
  geom_point(aes(color = Spp_Lifestage)) + 
  labs(title = "tick abundance - by species and life stage", x = "Visit", y = "# of ticks")
```

How does each site differ in tick abundance? 
**remember:** GA had 0 ticks the entire study 
```{r, message=FALSE}
site1 <- ticks %>%
  group_by(Site_ID) %>%
  summarise(total = n())
site1[18,] <- list("GA", 0)

site <- ticks %>%
  unite("Spp_Lifestage", Species, Lifestage) %>%
  group_by(Spp_Lifestage, Site_ID, Field_Type) %>%
  summarise(total = n())
site[52,] <- list("AA_A","GA","Manicured",0)

site$Site_ID <- factor(site$Site_ID, levels = c("GA","HW","RP","UG","JM","PC","29RD","FC","LL","DF","HT","MSM","SW","HC","SF","PP","SR","MSN"
))

p1 <- ggplot(data = site, aes(x=Site_ID, y=total, fill =Spp_Lifestage)) + 
  theme_classic() + 
  geom_bar(stat = "identity") + 
  labs(title = "Spp_Lifestage", x = "Site", y = "# of ticks")

p2 <- ggplot(data = site, aes(x=Site_ID, y=log1p(total), fill =Spp_Lifestage)) + 
  theme_classic() + 
  geom_bar(stat = "identity") + 
  labs(title = "Spp_Lifestage", x = "Site", y = "log(# of ticks)")

gridExtra::grid.arrange(p1,p2, ncol=2)
```

## Part 2: Visualize *Amblyomma americanum* data 

Let's work some more with just *Amblyomma americanum* since it is by far the most abundant species of tick collected during the study
```{r}
aa <- ticks %>%
  filter(Species == "AA")
head(aa)
```

Let's plot the count of *A.americanum* (nymphs and adults combined) by visit and site 
```{r, message=FALSE=}
aa_visit <- aa %>%
  group_by(Site_ID, Visit) %>%
  summarise(total = n())

ggplot(data = aa_visit, aes(x=Visit, y=total, col = Site_ID)) + 
  theme_classic() + 
  geom_point() + 
  labs(title = "A.americanum", x = "Visit", y = "# of ticks")
```

Let's take a closer look at the seasonality of *A.americanum* by combining counts from all sites and keeping visits separate 
```{r, message=FALSE}
aa_allsites <- aa %>%
  group_by(Lifestage, Visit) %>%
  summarise(total = n())

g1 <- ggplot(data = aa_allsites, aes(x=Visit, y=total, fill = Lifestage)) + 
  theme_classic() + 
  geom_point(aes(color = Lifestage)) + 
  labs(title = "A.americanum", x = "Visit", y = "# of ticks")

g2 <- ggplot(data = aa_allsites, aes(x=Visit, y=total, fill = Lifestage)) + 
  theme_classic() + 
  geom_smooth(aes(color = Lifestage)) + 
  labs(title = "A.americanum", x = "Visit", y = "# of ticks")

gridExtra::grid.arrange(g1, g2, ncol =2)
```
**interesting:** Both adults and nymphs of *Amblyomma americanum* have similar seasonality of peak abundance in Alachua Co. (at least between January and June) 

Now let's combine counts across all visits and keep the sites seperate 
```{r, message=FALSE}
aa_allvisits <- aa %>%
  group_by(Site_ID, Lifestage) %>%
  summarize(total = n(),
            density = (total/12000) * 100)

## add in rows for the sites and life stages with no observations
aa_allvisits[31,] <- list("29RD", "A", 0 , 0)
aa_allvisits[32,] <- list("HW", "A", 0 , 0)
aa_allvisits[33,] <- list("UG", "A", 0, 0)
aa_allvisits[34,] <- list("UG", "N", 0, 0)
aa_allvisits[35,] <- list("GA", "A", 0, 0)
aa_allvisits[36,] <- list("GA", "N", 0, 0)

aa_allvisits$Site_ID <- factor(aa_allvisits$Site_ID, levels = c("GA","UG","HW","RP","JM","PC","29RD","FC","LL","DF","MSM","HT","HC","SW","SF","PP","SR","MSN"
))

ggplot(data = aa_allvisits, aes(x=Site_ID, y=total, fill = Lifestage)) + 
  theme_classic() + 
  geom_bar(stat = "identity") + 
  labs(title = "A.americanum", x = "Site", y = "# of ticks")

```

## Part 3: Visualize *Ixodes scapularis* data 

Let's investigate *Ixodes scapularis*, as it was the second most abundant tick species in the study and is of great public health interest
```{r}
is <- ticks %>%
  filter(Species == "IS")
head(is)
```

Now let's plot the count of I.scapularis (rembember there were only adults collected) by visit and site 
```{r, message=FALSE}
is_visit <- is %>%
  group_by(Site_ID, Visit) %>%
  summarise(total = n())

ggplot(data = is_visit, aes(x=Visit, y=total, col = Site_ID)) + 
  theme_classic() + 
  geom_point() + 
  labs(title = "I.scapularis", x = "Visit", y = "# of ticks")
```
let's take a closer look at the seasonality of I.scapularis by combining counts from all sites and keeping visits separate 
```{r, message=FALSE}
is_allsites <- is %>%
  group_by(Lifestage, Visit) %>%
  summarise(total = n())

g3 <- ggplot(data = is_allsites, aes(x=Visit, y=total, fill = Lifestage)) + 
  theme_classic() + 
  geom_point(aes(color = Lifestage)) + 
  labs(title = "I.scapularis", x = "Visit", y = "# of ticks")

g4 <- ggplot(data = is_allsites, aes(x=Visit, y=total, fill = Lifestage)) + 
  theme_classic() + 
  geom_smooth(aes(color = Lifestage)) + 
  labs(title = "I.scapularis", x = "Visit", y = "# of ticks")

gridExtra::grid.arrange(g3,g4, ncol=2)
```

now let's combine counts across all visits and keep the sites seperate 
```{r}
is_allvisits <- is %>%
  group_by(Site_ID, Lifestage) %>%
  summarize(total = n(),
            density = (total/12000) * 100)

## add in rows for the sites and life stages with no observations
is_allvisits[12,] <- list("29RD", "A", 0 , 0)
is_allvisits[13,] <- list("GA", "A", 0, 0)
is_allvisits[14,] <- list("RP", "A", 0, 0)
is_allvisits[15,] <- list("PC", "A", 0, 0)
is_allvisits[16,] <- list("FC", "A", 0, 0)
is_allvisits[17,] <- list("LL", "A", 0, 0)
is_allvisits[18,] <- list("HT", "A", 0, 0)

is_allvisits$Site_ID <- factor(is_allvisits$Site_ID, levels = c("GA","UG","HW","RP","JM","PC","29RD","FC","LL","DF","MSM","HT","HC","SW","SF","PP","SR","MSN"
))

ggplot(data = is_allvisits, aes(x=Site_ID, y=total, fill = Lifestage)) + 
  theme_classic() + 
  geom_bar(stat = "identity") + 
  labs(title = "A.americanum", x = "Site", y = "# of ticks")

```
The order of sites is the *I.scapularis* plot is the same as the *A. americanum* plot earlier. Just using the eyeball test this shows many of the sites with high *A. americanum* abundance also have *I.scapularis*, but there are some deviations from this trend. 


## Part 4 - Landscape analyses of Amblyomma americanum 

### 4.1: Prepare data 
Read in the covariate data for all 18 sites 
This file contains information on if the environment type was manicured or natural, the proportion of forest landcover and the PC1 and PC2 scores at multiple spatial scales (250m, 500m, 1km, 2km, 3km, 4km buffers)
```{r}
covar <- read.csv("AlCo_SitesCovariates.csv")  ## 18 sites 
head(covar)
```
explore the relationship between different buffers by plotting them using the package 'corrplot'

```{r}
library(corrplot)

covar_sub <- covar[,c(6:23)]
M <- cor(covar_sub)
#head(round(M,2))

corrplot(M, type = "upper", order = "hclust")
```
There is high correlation between proportion of forest and PC1 across all scales.  
We will need to compare models using individual covariates to determine the appropriate scale 


join the covariate data to the *A.americanum* data and summarize total and density by site 
```{r, message=FALSE}
aa_var <- aa_allvisits %>%
  left_join(covar)
head(aa_var)

aa_combined <- aa_allvisits %>%
  group_by(Site_ID) %>%
  summarise(total = sum(total),
            density = sum(density)) %>%
  left_join(covar)
head(aa_combined)

aa_combined$Field_Type <- as.factor(aa_combined$Field_Type)
```

### 4.2: Test for spatial "scale of effect" 
here I will work with combined adult and nymph dataset (adults and nymphs have similar patterns over space and time so it makes more sense to combince their analyses)

test for "scale of effect" using a buffer based approach - Forest cover 
```{r}
pres.250m<-glm(total ~ Forest250m, family = "poisson", data = aa_combined)
pres.500m<-glm(total ~ Forest500m, family = "poisson", data = aa_combined)
pres.1km<-glm(total ~ Forest1km, family = "poisson", data = aa_combined)
pres.2km<-glm(total ~ Forest2km, family = "poisson", data = aa_combined)
pres.3km<-glm(total ~ Forest3km, family = "poisson", data = aa_combined)
pres.4km<-glm(total ~ Forest4km, family = "poisson", data = aa_combined)


comb.mod<-model.sel(pres.250m, pres.500m, pres.1km, pres.2km, pres.3km, pres.4km)
comb.mod

scales<-c(250,500,1000,2000,3000,4000)

ll<-c(logLik(pres.250m),logLik(pres.500m),logLik(pres.1km),logLik(pres.2km),logLik(pres.3km),logLik(pres.4km))
plot(scales,ll, ylab="Log-likelihood", main = "forest cover")
lines(scales,ll)
```
these results indicate that 1km for forest cover is the best scale for combined nymphs and adults 

test for "scale of effect" using a buffer based approach - PC1
```{r}
pres.250m<-glm(total ~ PC1_250m, family = "poisson", data = aa_combined)
pres.500m<-glm(total ~ PC1_500m, family = "poisson", data = aa_combined)
pres.1km<-glm(total ~ PC1_1km, family = "poisson", data = aa_combined)
pres.2km<-glm(total ~ PC1_2km, family = "poisson", data = aa_combined)
pres.3km<-glm(total ~ PC1_3km, family = "poisson", data = aa_combined)
pres.4km<-glm(total ~ PC1_4km, family = "poisson", data = aa_combined)


comb.mod<-model.sel(pres.250m, pres.500m, pres.1km, pres.2km, pres.3km, pres.4km)
comb.mod

scales<-c(250,500,1000,2000,3000,4000)

ll<-c(logLik(pres.250m),logLik(pres.500m),logLik(pres.1km),logLik(pres.2km),logLik(pres.3km),logLik(pres.4km))
plot(scales,ll, ylab="Log-likelihood", main = "PC1")
lines(scales,ll)
```
perhaps 500m is the best scale for PC1 


### 4.3 generalize linear models (GLMs)! 

#### First, let's try a poisson distribution
```{r}
glm0 <- glm(total ~ 1, data = aa_combined, family = "poisson")
glm1 <- glm(total ~ Forest1km , data = aa_combined, family = "poisson")
glm2 <- glm(total ~ Field_Type, data = aa_combined, family = "poisson")
glm3 <- glm(total ~ Forest1km + Field_Type, data = aa_combined, family = "poisson")
glm4 <- glm(total ~ Forest1km * Field_Type, data = aa_combined, family = "poisson")

### compare AICc of models 
AICc(glm0, glm1, glm2, glm3, glm4)
summary(glm4)

stargazer(glm4, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)
```
glm4 is best model

now, first let's measure dispersion 
```{r}
n <- nrow(aa_combined)
p <- length(coef(glm4))
dispersion <- sum(e1^2)/n-p
dispersion
```
there is overdispersion so a poisson is NOT appropriate 

#### Second: is a negative binomial distribution appropriate? 
```{r}
nb.glm0 <- glm.nb(total ~ 1, data = aa_combined)
nb.glm1 <- glm.nb(total ~ Forest1km , data = aa_combined)
nb.glm2 <- glm.nb(total ~ Field_Type, data = aa_combined)
nb.glm3 <- glm.nb(total ~ Forest1km + Field_Type, data = aa_combined)
nb.glm4 <- glm.nb(total ~ Forest1km * Field_Type, data = aa_combined)
nb.glm5 <- glm.nb(total ~ PC1_1km , data = aa_combined)
nb.glm6 <- glm.nb(total ~ PC1_1km + Field_Type, data = aa_combined)
nb.glm7 <- glm.nb(total ~ PC1_1km * Field_Type, data = aa_combined)
nb.glm11 <- glm.nb(total ~ PC1_500m, data = aa_combined)
nb.glm12 <- glm.nb(total ~ PC1_500m + Field_Type, data = aa_combined)
nb.glm13 <- glm.nb(total ~ PC1_500m * Field_Type, data = aa_combined)

### compare AICc of models 
AICc(nb.glm0, nb.glm1, nb.glm2, nb.glm3, nb.glm4, nb.glm5, nb.glm6, nb.glm7)

AICc(nb.glm0, nb.glm2, nb.glm11, nb.glm12, nb.glm13)

stargazer(nb.glm3, nb.glm4, nb.glm6, nb.glm7, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)

stargazer(nb.glm12, nb.glm13, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)

```
lowest AICc is for PC1 at 500m scale 
lowest AICc does not include the interaction term - but many models are within 2 delta AIC 

#### plot model residuals 
```{r}
par(mfrow=c(2,2), mar=c(4,4,2,1))
plot(nb.glm12)
```
site 12 and 17 could be problimatic... 

#### test for spatial autocorrelation (Moran's I)

Before we interpret the models, let’s check whether the assumption of independent residuals is violated by spatial autocorrelation in the residuals.
To calculate and test Moran’s I, we first need to define neighbours and spatial weights.
There are many ways to define weights  

start by defining weights matrix using several graph types
```{r}
coords <- cbind(aa_combined$Easting, aa_combined$Northing)
colnames(coords) <- c("x", "y")
distmat <- as.matrix(dist(coords))
maxdist <- 2/3 * max(distmat) # this is the maximum distance to consider in correlogram/variogram

nb.gab <- spdep::graph2nb(spdep::gabrielneigh(coords), sym = TRUE) 
plot(nb.gab, coords)
listw.gab <- spdep::nb2listw(nb.gab)

nb.rel <- spdep::graph2nb(spdep::relativeneigh(coords), sym = TRUE) 
plot(nb.rel, coords)
listw.rel <- spdep::nb2listw(nb.rel)

#distance-based neighbors - can change the distance at which to consider 
neigh <- dnearneigh(x=coords, d1=0, d2=0.5*maxdist, longlat = F)
plot(neigh, coords)
listw.neigh <- nb2listw(neigh, style = "W")
```
test for spatial autocorrelation in explainatory and predictor variables
```{r}
spdep::moran.test(aa_combined$total, listw.gab)
spdep::moran.test(aa_combined$Forest1km, listw.gab)
spdep::moran.test(aa_combined$PC1_1km, listw.gab)
spdep::moran.test(aa_combined$PC1_500m, listw.gab)
```


now test model for autocorrelation in the model residuals 
```{r}
spdep::lm.morantest(nb.glm12, listw.gab) 
spdep::lm.morantest(nb.glm12, listw.rel) 
spdep::lm.morantest(nb.glm12, listw.neigh) 
```
no significant spatial autocorrelation in residuals for any of the weight matrices... cool! 


let's look at the top model 
```{r}
stargazer(nb.glm12, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)
```



let's see how removing the two sites that fall outside model assumptions affect things (12 and 17)
```{r}
#  remove the top outliers to have a look
#top_x_outlier <- 2
#cooksd <- cooks.distance(nb.glm12)
#influential <- as.numeric(names(sort(cooksd, decreasing = TRUE)[1:top_x_outlier]))

aa_screen <- aa_combined[-c(12,17), ]

plot1 <- ggplot(data = aa_combined, aes(x = PC1_500m, y = total)) +
  geom_point(aes(col = Field_Type)) + 
  geom_smooth(method = lm) +
  xlim(-3,3) + 
  ggtitle("Before")
plot2 <- ggplot(data = aa_screen, aes(x = PC1_500m, y = total)) +
  geom_point(aes(col = Field_Type)) + 
  geom_smooth(method = lm) +
  xlim(-3,3) + 
  ggtitle("After")

gridExtra::grid.arrange(plot1, plot2, ncol=2)

#### compare model results for full and screened glm 
nb.glm14 <- glm.nb(total ~ PC1_500m + Field_Type, data = aa_screen)

stargazer(nb.glm12, nb.glm14, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)
```
while the AIC and LL are much better for the screened data set, the models estimates and significance are minimally affected by the sites that fall outside assumptions



now let's plot the models - two methods for the same plot... starting with the forest cover 1km model
```{r}
df1 <- expand.grid(PC1_500m = c(-3,-2.5,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,2.5,3), Field_Type = c("Natural","Manicured"), total = NA)

df1$total <- predict(nb.glm12, newdata = data.frame(df1), type="response")

#predict(nb.glm12, newdata = data.frame(df1))
#predict(nb.glm12, newdata = data.frame(df1), interval="prediction")

#get 95% CI
#mm <- model.matrix(~ PC1_500m + Field_Type, df1)
#pvar <- diag(mm %*% tcrossprod(vcov(nb.glm12), mm))
#df1$lci <- df1$total - 1.96 * sqrt(pvar)
#df1$uci <- df1$total + 1.96 * sqrt(pvar)

#plot
plot <-ggplot(data = aa_combined, aes(x=PC1_500m, y=total, group=Field_Type))+
                    geom_point(aes(color=Field_Type, size = 2)) +
                    geom_line(data=df1, size = 2, aes(color=Field_Type)) + 
                    ylab("A.americanum abundance") +
                    xlab("PC1 at 500m")+
                    #ggtitle("PC1 and Environment Type as Predictors of tick count")+
                    theme_bw()+ 
                    theme(panel.grid.major=element_blank(),
                    panel.grid.minor=element_blank(),
                    legend.position = c(0.3,0.8)) +
                    scale_color_discrete(name = "Environment Type", labels = c("natural", "manicured"))
  

plot.log <-ggplot(data = aa_combined, aes(x=PC1_500m, y=total, group=Field_Type))+
                    geom_point(aes(color=Field_Type, size =2)) +
                    geom_line(data=df1, size = 2, aes(color=Field_Type)) + 
                    ylab("A.americanum abundance") +
                    xlab("PC1 at 500m")+
                    scale_y_log10() +  ## may or may not want to use a log axis.... 
                    #ggtitle("PC1 and Environment Type as Predictors of tick count")+
                    theme_bw()+ 
                    theme(panel.grid.major=element_blank(),
                    panel.grid.minor=element_blank(),
                    legend.position = c(0.3,0.8)) +
                    scale_color_discrete(name = "Environment Type", labels = c("natural", "manicured"))

library(gridExtra)
grid.arrange(plot, plot.log, ncol = 2)
```
### try and shift y-asis of log transformed PCA - add CIs around prediction?  

summary of top model 
```{r}
summary(nb.glm12)
```


pseudo r-squared of model 
```{r}
100*(54.865-20.811)/54.865
```
this is quite a high model fit!!! 


## Part 5 - Ixodes scapularis 

### Part 5.1: data prep

join the covariate data to the Ixodes scapularis data 
```{r, message=FALSE}
is_var <- is_allvisits %>%
  left_join(covar)
head(is_var)

is_combined <- is_allvisits %>%
  group_by(Site_ID) %>%
  summarise(total = sum(total),
            density = sum(density)) %>%
  left_join(covar)
head(is_combined)

is_combined$Field_Type <- as.factor(is_combined$Field_Type)
```


### 5.2: Test for spatial "scale of effect"
test for "scale of effect" using a buffer based approach 
for the final go i should probably derive more scales but for now i will work with what there is 

test for "scale of effect" using a buffer based approach - Forest cover 
```{r}
pres.250m<-glm(total ~ Forest250m, family = "poisson", data = is_combined)
pres.500m<-glm(total ~ Forest500m, family = "poisson", data = is_combined)
pres.1km<-glm(total ~ Forest1km, family = "poisson", data = is_combined)
pres.2km<-glm(total ~ Forest2km, family = "poisson", data = is_combined)
pres.3km<-glm(total ~ Forest3km, family = "poisson", data = is_combined)
pres.4km<-glm(total ~ Forest4km, family = "poisson", data = is_combined)


comb.mod<-model.sel(pres.250m, pres.500m, pres.1km, pres.2km, pres.3km, pres.4km)
comb.mod

scales<-c(250,500,1000,2000,3000,4000)

ll<-c(logLik(pres.250m),logLik(pres.500m),logLik(pres.1km),logLik(pres.2km),logLik(pres.3km),logLik(pres.4km))
plot(scales,ll, ylab="Log-likelihood", main = "forest cover")
lines(scales,ll)
```
250m and 2km have lowest AICc and largest LL for forest cover.... 

test for "scale of effect" using a buffer based approach - PC1 
```{r}
pres.250m<-glm(total ~ PC1_250m, family = "poisson", data = is_combined)
pres.500m<-glm(total ~ PC1_500m, family = "poisson", data = is_combined)
pres.1km<-glm(total ~ PC1_1km, family = "poisson", data = is_combined)
pres.2km<-glm(total ~ PC1_2km, family = "poisson", data = is_combined)
pres.3km<-glm(total ~ PC1_3km, family = "poisson", data = is_combined)
pres.4km<-glm(total ~ PC1_4km, family = "poisson", data = is_combined)

comb.mod<-model.sel(pres.250m, pres.500m, pres.1km, pres.2km, pres.3km, pres.4km)
comb.mod

scales<-c(250,500,1000,2000,3000,4000)

ll<-c(logLik(pres.250m),logLik(pres.500m),logLik(pres.1km),logLik(pres.2km),logLik(pres.3km),logLik(pres.4km))
plot(scales,ll, ylab="Log-likelihood", main = "PC1")
lines(scales,ll)
```
500m and 1km have lowest AICc and largest LL for PC1


### 5.3 generalize linear models (GLMs)! 

#### glm with poisson distribution 
```{r}
glm0 <- glm(total ~ 1, data = is_combined, family = "poisson")
glm1 <- glm(total ~ Forest2km , data = is_combined, family = "poisson")
glm2 <- glm(total ~ Field_Type, data = is_combined, family = "poisson")
glm3 <- glm(total ~ Forest2km + Field_Type, data = is_combined, family = "poisson")
glm4 <- glm(total ~ Forest2km * Field_Type, data = is_combined, family = "poisson")

### compare AICc of models 
AICc(glm0, glm1, glm2, glm3, glm4)
summary(glm4)

stargazer(glm3, glm4, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)
```
model without the interaction term has lowest AIC and AICc 

now, check model for overdispersion
```{r}
n <- nrow(aa_combined)
p <- length(coef(glm3))
dispersion <- sum(e1^2)/n-p
dispersion
```
as expected... there is overdispersion


#### does a negative binomial distribution work then? 
```{r}
nb.glm0 <- glm.nb(total ~ 1, data = is_combined)
nb.glm1 <- glm.nb(total ~ Field_Type, data = is_combined)
# models for forest cover at 250m and 2km buffers
nb.glm2 <- glm.nb(total ~ Forest250m , data = is_combined)
nb.glm3 <- glm.nb(total ~ Forest250m + Field_Type, data = is_combined)
nb.glm4 <- glm.nb(total ~ Forest250m * Field_Type, data = is_combined)
nb.glm5 <- glm.nb(total ~ Forest2km, data = is_combined)
nb.glm6 <- glm.nb(total ~ Forest2km + Field_Type, data = is_combined)
nb.glm7 <- glm.nb(total ~ Forest2km * Field_Type, data = is_combined)
# models for PC1 at 500m and 1km buffers
nb.glm8 <- glm.nb(total ~ PC1_500m, data = is_combined)
nb.glm9 <- glm.nb(total ~ PC1_500m + Field_Type, data = is_combined)
nb.glm10 <- glm.nb(total ~ PC1_500m * Field_Type, data = is_combined)
nb.glm11 <- glm.nb(total ~ PC1_1km , data = is_combined)
nb.glm12 <- glm.nb(total ~ PC1_1km + Field_Type, data = is_combined)
nb.glm13 <- glm.nb(total ~ PC1_1km * Field_Type, data = is_combined)

### compare AICc of models - forest cover 
AICc(nb.glm0, nb.glm1, nb.glm2, nb.glm3, nb.glm4, nb.glm5, nb.glm6, nb.glm7)

AICc(nb.glm0, nb.glm1, nb.glm8, nb.glm9, nb.glm10, nb.glm11, nb.glm12, nb.glm13)


stargazer(nb.glm6, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)

stargazer(nb.glm8, nb.glm9, nb.glm11, nb.glm12, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)
```
top model (using AIC) includes both forest/PC1 and field type variable but not the interaction term **use model WITHOUT interaction**  2km buffer for forest cover best; 500m and 1km buffer for PC1 very similar 


check the model assumptions 
```{r}
par(mfrow=c(2,2), mar=c(4,4,2,1))
plot(nb.glm6)
plot(nb.glm9)
plot(nb.glm12)
```
sites 2 and 13 could be problematic for forest cover 
site 2 could be probematic for PC1

#### spatial autocorrelation

start by defining weights matrix using several graph types - this is the same code used for *A.americanum*
```{r}
coords <- cbind(aa_combined$Easting, aa_combined$Northing)
colnames(coords) <- c("x", "y")
distmat <- as.matrix(dist(coords))
maxdist <- 2/3 * max(distmat) # this is the maximum distance to consider in correlogram/variogram

nb.gab <- spdep::graph2nb(spdep::gabrielneigh(coords), sym = TRUE) 
plot(nb.gab, coords)
listw.gab <- spdep::nb2listw(nb.gab)

nb.rel <- spdep::graph2nb(spdep::relativeneigh(coords), sym = TRUE) 
plot(nb.rel, coords)
listw.rel <- spdep::nb2listw(nb.rel)

#distance-based neighbors - can change the distance at which to consider 
neigh <- dnearneigh(x=coords, d1=0, d2=0.5*maxdist, longlat = F)
plot(neigh, coords)
listw.neigh <- nb2listw(neigh, style = "W")
```


test for spatial autocorrelation in explainatory and predictor variables - gabrial
```{r}
spdep::moran.test(is_combined$total, listw.gab)
spdep::moran.test(is_combined$Forest2km, listw.gab)
spdep::moran.test(is_combined$PC1_500m, listw.gab)
spdep::moran.test(is_combined$PC1_1km, listw.gab)
```
yes there is autocorrelation in the response and predictor variables (using the gabriel weights)

test for spatial autocorrelation in explainatory and predictor variables - relative
```{r}
spdep::moran.test(is_combined$total, listw.rel)
spdep::moran.test(is_combined$Forest2km, listw.rel)
spdep::moran.test(is_combined$PC1_500m, listw.rel)
spdep::moran.test(is_combined$PC1_1km, listw.rel)
```
yes there is autocorrelation in the response and predictor variables (using the relative weights)

test for spatial autocorrelation in explainatory and predictor variables - neighbor
```{r}
spdep::moran.test(is_combined$total, listw.neigh)
spdep::moran.test(is_combined$Forest1km, listw.neigh)
spdep::moran.test(is_combined$PC1, listw.neigh)
```
there is autocorrelation in the predictor variables, but NOT response (using the neighborhood weights)


now test model for autocorrelation in the residuals - Forest2km
```{r}
spdep::lm.morantest(nb.glm6, listw.gab) 
spdep::lm.morantest(nb.glm6, listw.rel) 
spdep::lm.morantest(nb.glm6, listw.neigh) 
```
there is spatial autocorrelation in model residuals using the relative and neighbor weights 


now test model for autocorrelation in the residuals - PC1 at 500m
```{r}
spdep::lm.morantest(nb.glm9, listw.gab) 
spdep::lm.morantest(nb.glm9, listw.rel) 
spdep::lm.morantest(nb.glm9, listw.neigh) 
```
there is spatial autocorrelation in model residuals using the relative and neighbor weights

now test model for autocorrelation in the residuals - PC1 at 1km
```{r}
spdep::lm.morantest(nb.glm12, listw.gab) 
spdep::lm.morantest(nb.glm12, listw.rel) 
spdep::lm.morantest(nb.glm12, listw.neigh) 
```
there is spatial autocorrelation in model residuals (all weights matrices)
the gab weights only should significance for the PC1_1km model... 

do i need to rework the *I. scapularis* models to account for spatial autocorrelation? 

add a function to plot correlograms 
```{r}
icorrelogram <- function(locations,z, binsize, maxdist){
  
  distbin <- seq(0,maxdist,by=binsize)
  Nbin <- length(distbin)-1
  moran.results <- data.frame("dist"= rep(NA,Nbin), "Morans.i"=NA,"null.lcl"=NA, "null.ucl"=NA)
  
  for (i in 1:Nbin){
    d.start<-distbin[i] 
    d.end<-distbin[i+1]
    neigh <- dnearneigh(x=locations, d1=d.start, d.end, longlat=F)
    wts <- nb2listw(neighbours=neigh, style='B', zero.policy=T)
    mor.i <- moran.mc(x=z, listw=wts, nsim=200, alternative="greater", zero.policy=T)  #note alternative is for P-value, so only 'significant if positive autocorrelation
    
    moran.results[i, "dist"]<-(d.end+d.start)/2 
    moran.results[i, "Morans.i"]<-mor.i$statistic 								                #observed moran's i
    moran.results[i, "null.lcl"]<-quantile(mor.i$res, probs = 0.025,na.rm = T)#95% null envelope	
    moran.results[i, "null.ucl"]<-quantile(mor.i$res, probs = 0.975,na.rm = T)#95% null envelope
  }
  return(moran.results)
}
```

plot a correlogram for the models
```{r}
#run function I provided for an indicator correlogram

#response variable 
#VATH.cor<-icorrelogram(locations=coords, z=is_combined$total, binsize=1000,maxdist=15000)

# save residuals for negative binomial models 
nb.glm6.res <- residuals(nb.glm6, type = "deviance")
nb.glm9.res <- residuals(nb.glm9, type = "deviance")
nb.glm12.res <- residuals(nb.glm12, type = "deviance")

#cor_plot <-icorrelogram(locations=coords, z=nb.glm6.res, binsize=1000,maxdist= 20000)
#cor_plot <-icorrelogram(locations=coords, z=nb.glm9.res, binsize=1000,maxdist= 20000)
cor_plot <-icorrelogram(locations=coords, z=nb.glm12.res, binsize=1000,maxdist= 20000)

round(head(cor_plot ,3),2)

#plot correlogram
plot(cor_plot$dist, cor_plot$Morans.i, ylim = c(-0.5, 0.5))
abline(h=0, lty = "dashed")
lines(cor_plot$dist, cor_plot$null.lcl)
lines(cor_plot$dist, cor_plot$null.ucl)

#figure out how to make a nicer plot 
#ggplot(data = cor_plot, aes(x = dist, y= Morans.i)) + 
#  geom_line() +
#  geom_smooth()
```
there is only spatial autocorrelation at one or two points at fairly large lag distances... and those points bairly fall outside the 95% null envelope 

from what i can see from Fletcher's book, methods to account for spatial autocorrelation mostly address the issue at small lag distances, not intermediate to large. so i am going to move forward with the model. 


#### use a negative binomial glm that can account for spatial correlation using the R package glmmTMB 
first, we will start by reproducing the same basic negative binomial GLMs as above, but this time using the glmmTMB function with 'family = nbinom2'
```{r}
library(glmmTMB)
library(bbmle)

tmb.nb0 <- glmmTMB(total ~ 1, data = is_combined, family = nbinom2)
tmb.nb1 <- glmmTMB(total ~ Field_Type, data = is_combined, family = nbinom2)
# models for forest cover at 2km 
tmb.nb2 <- glmmTMB(total ~ Forest2km, data = is_combined, family = nbinom2)
tmb.nb3 <- glmmTMB(total ~ Forest2km + Field_Type, data = is_combined, family = nbinom2)
tmb.nb4 <- glmmTMB(total ~ Forest2km * Field_Type, data = is_combined, family = nbinom2)
# models for PC1 at 500m and 1km buffers
tmb.nb5 <- glmmTMB(total ~ PC1_500m, data = is_combined, family = nbinom2)
tmb.nb6 <- glmmTMB(total ~ PC1_500m + Field_Type, data = is_combined, family = nbinom2)
tmb.nb7 <- glmmTMB(total ~ PC1_500m * Field_Type, data = is_combined, family = nbinom2)
tmb.nb8 <- glmmTMB(total ~ PC1_1km , data = is_combined, family = nbinom2)
tmb.nb9 <- glmmTMB(total ~ PC1_1km + Field_Type, data = is_combined, family = nbinom2)
tmb.nb10 <- glmmTMB(total ~ PC1_1km * Field_Type, data = is_combined, family = nbinom2)

AICtab(tmb.nb0, tmb.nb1, tmb.nb2, tmb.nb3, tmb.nb4)
AICtab(tmb.nb0, tmb.nb1, tmb.nb5, tmb.nb6, tmb.nb7, tmb.nb8, tmb.nb9, tmb.nb10)
```
for forest cover, model 3 has lowest AIC.
for PC1, model 6 and 9 have lowest AIC.
these are the corresponding models from the glm.nb models earlier 

now let's compare the glm.nb to glmmTMB models 
```{r}
summary(nb.glm6)
summary(tmb.nb3)
```
the model estimates are identical, but std.error and p-values are very similar 

```{r}
summary(nb.glm9)
summary(tmb.nb6)
```
again, the model estimates are identical, but std.error and p-values are very similar 

```{r}
summary(nb.glm12)
summary(tmb.nb9)
```
and again, the model estimates are identical, but std.error and p-values are very similar 

##### okay so i have confirmed that the glm.nb and glmmTMB with nbinom2 model results are very similar,

##### now let's add in spatial autocorrelation
there are multiple options for correlation structure, but i believe that an exponential covariance structure, using exp() is the way to go 

#### another appraoch... 
polynomial trend surface 

```{r}
#create column for easting and northing
is_combined$Easting_scale <- scale(is_combined$Easting)
is_combined$Northing_scale <- scale(is_combined$Northing)

nb.glm12.trend <- glm.nb(total ~ PC1_1km + Field_Type + poly(Easting_scale,3) + poly(Northing_scale, 3), data = is_combined)

summary(nb.glm12.trend)
```

is there spatial autocorrelation in the new model? 

```{r}
spdep::lm.morantest(nb.glm12.trend, listw.gab) 
spdep::lm.morantest(nb.glm12.trend, listw.rel) 
spdep::lm.morantest(nb.glm12.trend, listw.neigh) 
```
the trend surface seems to have worked... but maybe there is a better option? 


maybe a GAM? 
```{r}
library(mgcv)
nb.gam12 <- gam(total ~ PC1_1km + Field_Type + s(Easting, Northing), family = "nb", data = is_combined)
```

maybe an autocovariate model? 
```{r}
auto1km <- autocov_dist(is_combined$total, coords, nbs = 1000, type = "one", style = "B", zero.policy = T)

nb.glm12.auto <- glm.nb(total ~ PC1_1km + Field_Type + auto1km, data = is_combined)
summary(nb.glm12.auto)
```

is there spatial autocorrelation in the new model? 

```{r}
spdep::lm.morantest(nb.glm12.auto, listw.gab) 
spdep::lm.morantest(nb.glm12.auto, listw.rel) 
spdep::lm.morantest(nb.glm12.auto, listw.neigh) 
```

yep... 


try plotting to see what's happening with these different methods








```{r}
# fitst we need to create a numeric factor recording the coordinates of the sampled locations
is_combined$pos <- numFactor(scale(is_combined$Easting), scale(is_combined$Northing))
# create site as a dummy group factor to be used as a random term. it is 1 for all rows
is_combined$Site <- 1


# exp 
tmb.nb0.exp <- glmmTMB(total ~ 1 + (1|Site) + exp(pos + 0 |Site),  data = is_combined, family = nbinom2)
tmb.nb1.exp <- glmmTMB(total ~ Field_Type + (1|Site) + exp(pos + 0 | Site),  data = is_combined, family = nbinom2)
tmb.nb2.exp <- glmmTMB(total ~ Forest2km + (1|Site) + exp(pos + 0 |Site), data = is_combined, family = nbinom2)
tmb.nb3.exp <- glmmTMB(total ~ Forest2km + Field_Type + (1|Site)  + exp(pos + 0 | Site), data = is_combined, family = nbinom2)
tmb.nb4.exp <- glmmTMB(total ~ PC1_500m + (1|Site) + exp(pos + 0 | Site), data = is_combined, family = nbinom2)
tmb.nb5.exp <- glmmTMB(total ~ PC1_500m + Field_Type + (1|Site) + exp(pos + 0 | Site), data = is_combined, family = nbinom2)
tmb.nb6.exp <- glmmTMB(total ~ PC1_1km + (1|Site) + exp(pos + 0 | Site), data = is_combined, family = nbinom2)
tmb.nb7.exp <- glmmTMB(total ~ PC1_1km + Field_Type + (1|Site) + exp(pos + 0 | Site), data = is_combined, family = nbinom2)


AICtab(tmb.nb0.exp, tmb.nb1.exp, tmb.nb2.exp, tmb.nb3.exp, tmb.nb4.exp, tmb.nb5.exp, tmb.nb6.exp, tmb.nb7.exp)
```
model convergence problems with Forest2km models 


is there spatial autocorrelation in the new models? 
```{r}
spdep::lm.morantest(tmb.nb5.exp, listw.gab) 
spdep::lm.morantest(tmb.nb5.exp, listw.rel) 
spdep::lm.morantest(tmb.nb5.exp, listw.neigh) 
```



more models fit using the exponential autocorrelation - exponential seems to be the way to go... 

look at the top models that converged
```{r}
summary(tmb.nb5.gau)
summary(tmb.nb6)
```


check model fit 
```{r}
library(DHARMa)
sims <- simulateResiduals(tmb.nb5.exp)
plot(sims)
```
model fit looks good... 



plot the effects of PC1 and Enviro type 

```{r}
# the effect of elevation
newdat <- expand.grid(PC1 = c(-3,-2.5,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,2.5,3), Forested_Manicured = c("Forest","Manicured"), total = NA)

newdat$total <- predict(nb.glm6, newdata = data.frame(newdat), type = "response")

# turn this into a model matrix
mm <- model.matrix(~ PC1 + Forested_Manicured, newdat)
#newdat$total <- mm %*% fixef(tmb.nb6)$cond + mean(c(0, fixef(tmb.nb6)$cond[3])) # predicted values removing region effects
pvar <- diag(mm %*% tcrossprod(vcov(tmb.nb6)$cond, mm))
newdat$lci <- newdat$total - 1.96 * sqrt(pvar)
newdat$uci <- newdat$total + 1.96 * sqrt(pvar)

gg1 <- ggplot(data = is_combined, aes(x = PC1, y = total, group = Forested_Manicured)) +
  geom_point(aes(color=Forested_Manicured)) +
  geom_line(data = newdat, aes(color=Forested_Manicured)) +
  geom_ribbon(data = newdat, aes(ymin = lci, ymax = uci), alpha = 0.2) +
  theme_bw()
gg1

#gridExtra::grid.arrange(gg1, gg2, ncol=2)
```





first try removing outliers from dataset and see if that takes care of spatial autocorrelation 
optional: possible removal of outliers 
```{r}
#  remove the top two outliers to have a look - for nb.glm3 this would be 2 and 13 
top_x_outlier <- 2
cooksd <- cooks.distance(nb.glm3)
influential <- as.numeric(names(sort(cooksd, decreasing = TRUE)[1:top_x_outlier]))

is_screen <- is_combined[-influential, ]

plot1 <- ggplot(data = is_combined, aes(x = Forest2km, y = total)) +
  geom_point(aes(col = Forested_Manicured)) + 
  geom_smooth(method = lm) +
  xlim(0, 1) + 
  ggtitle("Before")
plot2 <- ggplot(data = is_screen, aes(x = Forest2km, y = total)) +
  geom_point(aes(col = Forested_Manicured)) + 
  geom_smooth(method = lm) +
  xlim(0, 1) + 
  ggtitle("After")

gridExtra::grid.arrange(plot1, plot2, ncol=2)

#### compare model results for full and screened glm 
nb.glm0.reduced <- glm.nb(total ~ 1, data = is_screen)
nb.glm1.reduced <- glm.nb(total ~ Forest2km , data = is_screen)
nb.glm2.reduced <- glm.nb(total ~ Forested_Manicured, data = is_screen)
nb.glm3.reduced <- glm.nb(total ~ Forest2km + Forested_Manicured, data = is_screen)
nb.glm4.reduced <- glm.nb(total ~ Forest2km * Forested_Manicured, data = is_screen)
nb.glm5.reduced <- glm.nb(total ~ PC1 , data = is_screen)
nb.glm6.reduced <- glm.nb(total ~ PC1 + Forested_Manicured, data = is_screen)
nb.glm7.reduced <- glm.nb(total ~ PC1 * Forested_Manicured, data = is_screen)

### compare AICc of models 
AICc(nb.glm0.reduced, nb.glm1.reduced, nb.glm2.reduced, nb.glm3.reduced, nb.glm4.reduced, nb.glm5.reduced, nb.glm6.reduced, nb.glm7.reduced)

stargazer(nb.glm3, nb.glm3.reduced, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)

stargazer(nb.glm6, nb.glm6.reduced, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)
```

plot model residuals
```{r}
par(mfrow=c(2,2), mar=c(4,4,2,1))
plot(nb.glm3.reduced)
```
doesn't really improve... new sites are now outside ranges


```{r}
par(mfrow=c(2,2), mar=c(4,4,2,1))
plot(nb.glm6.reduced)
```
doesn't really improve... new sites are now outside ranges


test for spatial autocorrelation in the top models using the screened data set 

first i need to recreate the spatial weights matrix without the outlier sites 

```{r}
coords.screen <- coords[-influential, ]

nb.gab.screen <- spdep::graph2nb(spdep::gabrielneigh(coords.screen), sym = TRUE) 
plot(nb.gab.screen, coords.screen)
listw.gab.screen <- spdep::nb2listw(nb.gab.screen)

nb.rel.screen <- spdep::graph2nb(spdep::relativeneigh(coords.screen), sym = TRUE) 
plot(nb.rel.screen, coords.screen)
listw.rel.screen <- spdep::nb2listw(nb.rel.screen)

#distance-based neighbors 
neigh.screen <- dnearneigh(x=coords.screen, d1=0, d2=0.5*maxdist, longlat = F)
plot(neigh.screen, coords.screen)
listw.neigh.screen <- nb2listw(neigh.screen, style = "W")
```



now test model for autocorrelation in the residuals - Forest2km
```{r}
spdep::lm.morantest(nb.glm3.reduced, listw.gab.screen) 
spdep::lm.morantest(nb.glm3.reduced, listw.rel.screen) 
spdep::lm.morantest(nb.glm3.reduced, listw.neigh.screen) 

```
there is spatial autocorrelation in model residuals!!! 
need to rework the Forest2km models...

now test model for autocorrelation in the residuals - PC1
```{r}
spdep::lm.morantest(nb.glm6.reduced, listw.gab.screen) 
spdep::lm.morantest(nb.glm6.reduced, listw.rel.screen) 
spdep::lm.morantest(nb.glm6.reduced, listw.neigh.screen) 

```
there is spatial autocorrelation in model residuals!!! 
need to rework the PC1 models...





okay, now try to account for spatial autocorrelation by fitting models with spatially correlated error (GLS) using the package 'nlme'

```{r}
# original model
#nb.glm3 <- glm.nb(total ~ Forest2km + Forested_Manicured, data = is_combined)

library(nlme)
gls1 <- gls(total ~ Forest2km + Forested_Manicured, data = is_combined)
summary(gls1)
```




now let's plot the models: REDO THIS WITH MODEL THAT ACCOUNTS FOR SPATIAL AUTOCORRELATION!!! 
```{r}
df1 <- expand.grid(Forest2km = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9), Forested_Manicured = c("Forest","Manicured"), abundance = NA)

df1$abundance <- predict(nb.glm3, newdata = data.frame(df1), type = "response")

p1 <- ggplot(df1, aes(x=Forest2km, y=abundance, group = Forested_Manicured)) + 
         geom_line(size=2, aes(color=Forested_Manicured))+
  ylab("Ixodes scapularis abundance")+
  xlab("% Forest within 2km")+
  #scale_y_log10() + 
  #ggtitle("Forest2km and Land Type as Predictors of tick count - all sites")+
  theme_bw()+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        legend.position = "none") +
  scale_fill_grey()

p2 <- ggplot(df1, aes(x=Forest2km, y=abundance, group = Forested_Manicured)) + 
         geom_line(size=2, aes(color=Forested_Manicured))+
  ylab("Ixodes scapularis abundance")+
  xlab("% Forest within 2km")+
  scale_y_log10() + 
  #ggtitle("Forest2km and Land Type as Predictors of tick count - all sites")+
  theme_bw()+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        legend.position = c(0.3,0.8)) +
  scale_fill_grey() +
  scale_color_discrete(name = "Environment Type", labels = c("natural", "manicured"))

grid.arrange(p1, p2, ncol = 2)
```

pseudo r-squared of model 
```{r}
100*(32.29-17.71)/32.29 
```



PC1 model 
check for overdispersion
```{r}
e6 <- resid(nb.glm6, type = "pearson")
n <- nrow(is_combined)
p <- length(coef(nb.glm6)) +1
dispersion <- sum(e6^2)/(n-p)
dispersion
```
negative binomial has much lower AIC and more appropriate dispersion stat

now for the validation steps 
```{r}
#plot pearson residuals
par(mfrow = c(2, 2), mar = c(5,5,2,2))
E6 <- resid(nb.glm6, type = "pearson")
F6 <- fitted(nb.glm6, type = "response")
plot(x = F6, 
     y = E6,
     xlab = "Fitted values",
     ylab = "Residuals",
     cex.lab = 1.5)
abline(0, 0, lty = 2)

plot(cooks.distance(nb.glm6),
     type = "h",
     ylim=c(0,1),cex.lab = 1.5)
abline(h=1)

#Independence:
plot(x = is_combined$Forest2km, 
     y = E6,
     xlab = "PC1",
     ylab = "Pearson residuals", cex.lab = 1.5)
abline(0,0, lty=2)

boxplot(E6 ~ Forested_Manicured, 
        data = is_combined, 
        xlab = "type",
        ylab = "Pearson residuals",
        cex.lab = 1.5)
```

```{r}
xyplot(E6 ~ PC1 | factor(Forested_Manicured), 
       data = is_combined,
       xlab = list(label = "PC1", cex = 1.5),
       ylab = list(label = "Pearson residuals", cex = 1.5),
       panel = function(x,y){
         panel.points(x,y, col = 1, pch = 16, cex = 0.7)
         panel.loess(x,y, col = 1, lwd = 2)
         panel.abline(h=0)
       })
``` 

now let's plot the models: 
```{r}
df1 <- expand.grid(PC1 = c(-3,-2.5,-2,-1.5,-1,-0.5,0,0.5,1,1.5,2,2.5,3), Forested_Manicured = c("Forest","Manicured"), abundance = NA)

df1$abundance <- predict(nb.glm6, newdata = data.frame(df1), type = "response")

p3 <- ggplot(df1, aes(x=PC1, y=abundance, group = Forested_Manicured)) + 
         geom_line(size=2, aes(color=Forested_Manicured))+
  ylab("Ixodes scapularis abundance")+
  xlab("PC1")+
  #scale_y_log10() + 
  #ggtitle("PC1 and Land Type as Predictors of tick count - all sites")+
  theme_bw()+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        legend.position = "none") +
  scale_fill_grey()

p4 <- ggplot(df1, aes(x=PC1, y=abundance, group = Forested_Manicured)) + 
         geom_line(size=2, aes(color=Forested_Manicured))+
  ylab("Ixodes scapularis abundance")+
  xlab("PC1")+
  scale_y_log10() + 
  #ggtitle("PC1 and Land Type as Predictors of tick count - all sites")+
  theme_bw()+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        legend.position = c(0.3,0.8)) +
  scale_fill_grey() +
  scale_color_discrete(name = "Environment Type", labels = c("natural", "manicured"))

grid.arrange(p3, p4, ncol = 2)
```

pseudo r-squared of model 
```{r}
100*(36.41-18.54)/36.41 
```

