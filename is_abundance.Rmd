---
title: "is_abundance"
author: "Kimberly Ledger"
date: "2/21/2022"
output: html_document
---

this is a branch off of the AA analysis... same this but looking at Ixodes scapularis 


### 4.1: Prepare data 
Read in the covariate data for all 18 sites 
This file contains information on if the environment type was manicured or natural, the proportion of forest landcover at 500m, 1km, and 2km buffers, and the PC1 and PC2 land use metrics at 1km buffers
```{r}
covar <- read.csv("AlCo_SitesCovariates.csv")  ## 18 sites 
head(covar)
```


join the covariate data to the Ixodes scapularis data 
```{r}
is_var <- is_allvisits %>%
  left_join(covar)
head(is_var)

is_combined <- is_allvisits %>%
  group_by(Site_ID) %>%
  summarise(total = sum(total),
            density = sum(density)) %>%
  left_join(covar)
head(is_combined)

is_combined$Forested_Manicured <- as.factor(is_combined$Forested_Manicured)
```


### 4.2: Test for spatial "scale of effect" and spatial autocorrelation 
test for "scale of effect" using a buffer based approach 
for the final go i should probably derive more scales but for now i will work with what there is 

```{r}
pres.500m<-glm(total ~ Forest500m, family = "poisson", data = is_combined)
pres.1km<-glm(total ~ Forest1km, family = "poisson", data = is_combined)
pres.2km<-glm(total ~ Forest2km, family = "poisson", data = is_combined)

comb.mod<-model.sel(pres.500m, pres.1km, pres.2km)
comb.mod

scales<-c(500,1000,2000)

ll<-c(logLik(pres.500m),logLik(pres.1km),logLik(pres.2km))
plot(scales,ll, ylab="Log-likelihood", main = "combined")
lines(scales,ll)
```

2km is best scales tested so far....for IS 

### 4.3: test for spatial autocorrelation 

first, calculate the distance matrix 
```{r}
coords <- cbind(is_combined$Easting, aa_combined$Northing)
colnames(coords) <- c("x", "y")
distmat <- as.matrix(dist(coords))
maxdist <- 2/3 * max(distmat) # this is the maximum distance to consider in correlogram/variogram
```

Method #1: correlograms (smoothed) in ncf: 
here we can use splines with bootstrapping

```{r}
library(ncf)
#spline correlogram with 95% pointwise bootstrap confidence intervals and maximum lag distance of 10 km
spline.corr <- spline.correlog(x = is_combined$Easting, y = is_combined$Northing, z = is_combined$total, 
                               xmax = maxdist, resamp=1000, type="boot") ##the number of resamples for the bootstrap or the null distribution

summary(spline.corr)
#plot shows point-wise 95% CIs from bootstrap:
plot(spline.corr)
```
no evidence of spatial autocorrelation 

Method #2: correlograms in spdep 

```{r}
library(spdep)
# first, calculate Moran's i global statistic

#make a matrix with coordinates, needed for spdep
#make a neighborhood list to include. d1 is minimum distance, d2 is max distance
neigh <- dnearneigh(x=coords, d1=0, d2=20000, longlat=F) 

#plot the neighorhood
plot(neigh,coordinates(coords))

#create weights for the neighbors. We will use row-standardized weights (W); i.e., rows sum to 1
#zero.policy allows the function to work if there are points that don't fall into this category 
#(i.e., if a point has no neighbors within 0-2 meters, as above)
wts <- nb2listw(neighbours=neigh, style='W', zero.policy=T) #default style W

#moran's i with a Monte Carlo permutation test (similar to the permutations with variograms above
#which is useful for 0/1 data
mor.mc <- moran.mc(x=is_combined$total, listw=wts, nsim=999, zero.policy=T) #monte carlo
mor.norm <- moran.test(x=is_combined$total, listw=wts, randomisation=F, zero.policy=T)#normal approximation

mor.mc  #no spatial autocorrelation
mor.norm  #no spatial autocorrelation 
```

both methods generate similar estimates of Moran's I (-0.05) and non-significant p-values (>0.4)
we can accept the null hypothesis that there is no spatial autocorrelation


### 4.4 generalize linear models (GLMs)! 

```{r}
glm0 <- glm(total ~ 1, data = is_combined, family = "poisson")
glm1 <- glm(total ~ Forest2km , data = is_combined, family = "poisson")
glm2 <- glm(total ~ Forested_Manicured, data = is_combined, family = "poisson")
glm3 <- glm(total ~ Forest2km + Forested_Manicured, data = is_combined, family = "poisson")
glm4 <- glm(total ~ Forest2km * Forested_Manicured, data = is_combined, family = "poisson")

### compare AICc of models 
AICc(glm0, glm1, glm2, glm3, glm4)
summary(glm4)

stargazer(glm3, glm4, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)
```
model without the interaction term has lowest AIC and AICc 

now, check model assumptions 
```{r}
#plot pearon residuals
e1 <- resid(glm3, type = "pearson")
f1 <- fitted(glm3)
eta <- predict(glm3, type = "link")

plot(f1, e1, xlab = "fitted values", ylab = "pearson resid")
abline(h=0, v=0, lty=2)

plot(eta, e1, xlab = "eta", ylab = "pearson resid")
abline(h=0, v=0, lty=2)

plot(aa_combined$Forest1km, e1, xlab = "forest cover", ylab = "pearson resid")
abline(h=0, v=0, lty=2)

### well first let's measure dispersion 
n <- nrow(aa_combined)
p <- length(coef(glm3))
dispersion <- sum(e1^2)/n-p
dispersion
```
there is overdispersion... try out nb glm 



does a negative binomial distribution work then? 
```{r}
nb.glm0 <- glm.nb(total ~ 1, data = is_combined)
nb.glm1 <- glm.nb(total ~ Forest2km , data = is_combined)
nb.glm2 <- glm.nb(total ~ Forested_Manicured, data = is_combined)
nb.glm3 <- glm.nb(total ~ Forest2km + Forested_Manicured, data = is_combined)
nb.glm4 <- glm.nb(total ~ Forest2km * Forested_Manicured, data = is_combined)

### compare AICc of models 
AICc(nb.glm0, nb.glm1, nb.glm2, nb.glm3, nb.glm4)
summary(nb.glm4)

stargazer(nb.glm2, nb.glm3, nb.glm4, type = "text",
          intercept.bottom = FALSE, 
          single.row=FALSE,     
          notes.append = FALSE, 
          header=FALSE)

```

top model (using AIC) includes both variable but not the interaction term... 
**use model WITHOUT interaction** 

check for overdispersion
```{r}
e4 <- resid(nb.glm3, type = "pearson")
n <- nrow(is_combined)
p <- length(coef(nb.glm3)) +1
dispersion <- sum(e4^2)/(n-p)
dispersion
```

negative binomial has much lower AIC and more appropriate dispersion stat

now for the validation steps 

```{r}
#plot pearson residuals
par(mfrow = c(2, 2), mar = c(5,5,2,2))
E5 <- resid(nb.glm3, type = "pearson")
F5 <- fitted(nb.glm3, type = "response")
plot(x = F5, 
     y = E5,
     xlab = "Fitted values",
     ylab = "Residuals",
     cex.lab = 1.5)
abline(0, 0, lty = 2)

plot(cooks.distance(nb.glm3),
     type = "h",
     ylim=c(0,1),cex.lab = 1.5)
abline(h=1)

#Independence:
plot(x = is_combined$Forest2km, 
     y = E5,
     xlab = "Mean depth (km)",
     ylab = "Pearson residuals", cex.lab = 1.5)
abline(0,0, lty=2)

boxplot(E5 ~ Forested_Manicured, 
        data = is_combined, 
        xlab = "type",
        ylab = "Pearson residuals",
        cex.lab = 1.5)
```


```{r}
library(lattice)
xyplot(E5 ~ Forest2km | factor(Forested_Manicured), 
       data = is_combined,
       xlab = list(label = "forest cover", cex = 1.5),
       ylab = list(label = "Pearson residuals", cex = 1.5),
       panel = function(x,y){
         panel.points(x,y, col = 1, pch = 16, cex = 0.7)
         panel.loess(x,y, col = 1, lwd = 2)
         panel.abline(h=0)
       })

```

now let's plot the models -


```{r}
df1 <- expand.grid(Forest2km = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9), Forested_Manicured = c("Forest","Manicured"), abundance = NA)

df1$abundance <- predict(nb.glm3, newdata = data.frame(df1), type = "response")

ggplot(df1, aes(x=Forest2km, y=abundance, group = Forested_Manicured)) + 
         geom_line(size=2, aes(color=Forested_Manicured))+
  ylab("Ixodes scapularis abundance")+
  xlab("% Forest within 2km")+
  #scale_y_log10() + 
  ggtitle("Forest1km and Land Type as Predictors of tick count - all sites")+
  theme_bw()+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank()) +
  scale_fill_grey()

ggplot(df1, aes(x=Forest2km, y=abundance, group = Forested_Manicured)) + 
         geom_line(size=2, aes(color=Forested_Manicured))+
  ylab("Ixodes scapularis abundance")+
  xlab("% Forest within 2km")+
  scale_y_log10() + 
  ggtitle("Forest1km and Land Type as Predictors of tick count - all sites")+
  theme_bw()+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank()) +
  scale_fill_grey()
```

pseudo r-squared of model 
```{r}
100*(32.29-17.71)/32.29 
```



